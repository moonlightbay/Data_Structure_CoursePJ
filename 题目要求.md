题目要求
本项目要求自行预处理 Topology Zoo 数据集，并设计一个动态路由算法程序（使用C/C++，编译后可执行文件名称为Q1.exe），能够在动态波动的网络环境下，迅速、高效地计算最短路由。具体要求如下：

预处理阶段（可以使用 Python 等其他语言）：
预处理 Topology Zoo 数据集，将预处理的缓存文件保存在与 Q1.exe 同一目录下，缓存文件类型随意（可以是单个文件、或单个文件夹内有多个文件）

求解阶段（只能使用 C/C++ ）：
给定一个网络的 Network 名称（如 Us Signal），可以从缓存文件中读取该网络的拓扑数据，构建网络拓扑图（带权无向图），其中节点 id 为整数，链路时延（边权）为浮点数（毫秒）。
给定一个节点 id（整数），将该 id 作为起始节点，并计算并输出该节点到网络中所有其它节点的最短路径时延（单位：毫秒）。

给定一系列事件：
单个/多个节点停用事件：当节点停用后，所有与该节点相连的链路将被断开。格式为：down N <node_id1> <node_id2> ... <node_idn>，其中 node_id1、node_id2、...、node_idn 为停用节点的 id（整数），N 为停用节点的数量。程序无需输出。
单个/多个节点启用事件：当节点启用后，所有与该节点相连的链路将被恢复。格式为：up N <node_id1> <node_id2> ... <node_idn>，其中 node_id1、node_id2、...、node_idn 为启用节点的 id（整数），N 为启用节点的数量。程序无需输出。

负载波动事件（选做）：链路的时延不再是固定值，而是会在之前的值上进行增量或减量。格式为：fluc N <node_id1_a> <node_id1_b> <delta1> <node_id2_a> <node_id2_b> <delta2> ...，其中 node_id1_a、node_id1_b 为链路的两端节点，delta1 为链路时延的增量（单位：毫秒，负数为减量），N 为链路数量。负载波动后，链路的时延会进行更新（即下一次的负载波动事件会在更新后的时延上进行增量或减量）。链路时延的最小值为 1 毫秒，最大值为 1000 毫秒。程序无需输出。
更新最短路、输出事件：格式为：update。当触发 update 事件时，程序需计算并输出当前网络中所有节点的最短路径时延（单位：毫秒）。最短路径时延的定义请见输出格式板块。

输入、输出格式

输入格式
输入包含多个 testcase，每个testcase 内容如下：

第一行：<Network>，表示网络名称（如 Us Signal）。

第二行：<start_node_id>，表示起始节点的 id（整数）。

第三行：正整数 M（≥2），表示事件的数量。

往下的 M 行，每行表示一个事件，格式如下：

down N <node_id1> <node_id2> ... <node_idn>：表示停用节点 node_id1、node_id2、...、node_idn。
up N <node_id1> <node_id2> ... <node_idn>：表示启用节点 node_id1、node_id2、...、node_idn。
（可选）fluc N <node_id1_a> <node_id1_b> <delta1> <node_id2_a> <node_id2_b> <delta2> ...：表示链路时延波动。
update：表示更新最短路径时延并输出。
事件出现的先后顺序随机。第一个事件一定不是 update 事件，最后一个事件一定是 update 事件。
若已启用的节点再次启用、已停用的节点再次停用，则这些节点的状态不做任何变动；起始节点的状态保证不会做任何变动（一直为启动）。
负载波动事件中的链路时延增量（delta）可以为负数，表示减小时延。

输出格式
在每个 testcase 内：

接受第二行的起始节点输入后，输出一行，代表该节点到网络中所有其它节点的最短路径时延（单位：毫秒）。
每接受一次 update 事件，输出一行，代表该节点到网络中所有其它节点的最短路径时延（单位：毫秒）。
最短路径时延定义为：从起始节点到目标节点若存在一条最短路径，则输出该路径的时延总和（边权之和）；若路径不可达，则输出 -1。
输出最短路径时延的格式为：

<delay1> ... <delay x-1> <delay x+1> ... <delay n>\n
其中 <delay i> 为起始节点到节点 i 的最短路径时延（单位：毫秒，保留2位小数），按照节点 id 的升序排列。其中节点 x 为起始节点，故延迟值 <delay x> 不输出。若某个节点不可达，则输出 -1。行末以换行符 \n 结尾。

示例输入、输出
后续会继续发布参考的输入输出示例、testcase，请耐心等待。

注意事项
最终提交的内容为一个压缩包，内容包含：
Q1.c/Q1.cpp源代码文件，Q1.exe 可执行文件（若选做负载波动事件，则源代码文件须命名为 Q1_plus.c/Q1_plus.cpp，可执行文件须命名为 Q1_plus.exe）
Topology Zoo 数据集预处理后的缓存文件（如 edgelist.txt）或文件夹
预处理数据集用到的所有程序源码等（如 Python 脚本）
单源最短路可以使用 Dijkstra 算法求解。由于事件数量可能较多，每次全局更新最短路径时延的复杂度较高，故需要对算法策略进行优化，例如采用局部更新方法，以提高算法效率。
可以使用 STL 的 priority_queue 来实现 Dijkstra 算法。
可以采用更高效的数据结构，但需自行实现，请谨慎尝试。
评分时会根据结果的正确性和运行时间进行综合评测。
本文档可能会根据实际情况进行小范围的错误修正等更新，请及时关注 elearning 的通知。